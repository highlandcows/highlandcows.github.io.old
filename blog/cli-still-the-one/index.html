<!DOCTYPE html><html lang="en" class="astro-7DC3FJFN">
    <head>
        <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Blog | The Unix CLI: You&#39;re Still The One</title>
    <meta name="title" content="Blog | The Unix CLI: You're Still The One">
    <meta name="description" content="Why the Unix Command Line still my go-to tool">

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="shortcut icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

    <meta httpEquiv="X-UA-Compatible" content="IE=edge">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">

    <!-- Open Graph Tags (Facebook) -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Blog | The Unix CLI: You're Still The One">
    
    <meta property="og:description" content="Why the Unix Command Line still my go-to tool">
    

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Blog | The Unix CLI: You're Still The One">
    
    <meta property="twitter:description" content="Why the Unix Command Line still my go-to tool">
    

    

    <link rel="stylesheet" href="/assets/7e8648bf.905242a4.css" />
<link rel="stylesheet" href="/assets/22d5a920.13929d2e.css" />
<link rel="stylesheet" href="/assets/131e63a5.2883bd8d.css" /><script type="module" src="/hoisted.9c0718d3.js"></script></head>
    <body class="font-sans antialiased min-h-screen">
    <div class="bg-gray-100 dark:bg-gray-800 transition-colors">
        <main class="mx-auto max-w-4xl px-4 md:px-0">
            <br class="my-4 astro-QG7TIMHI"><header class="header astro-RQQND6GD">
    <div class="header__logo astro-RQQND6GD">
        <a href="/" class="avatar astro-RQQND6GD">
            <img class="header__logo-img astro-RQQND6GD" src="/assets/highland-cow-head.png" alt="Highland Cows logo">
        </a>
    </div>
    <div class="header__meta flex-1 astro-RQQND6GD">
        <h3 class="header__title dark:text-primarySecondaryDark astro-RQQND6GD">
            <a href="" class="astro-RQQND6GD">Highland Cows</a>
        </h3>
        <div class="header__meta-more flex astro-RQQND6GD">
            <p class="header__desc astro-RQQND6GD">
                Technical ideas &amp; other musings
            </p>
            <nav class="header__nav flex astro-RQQND6GD">
                <ul class="header__ref-list astro-RQQND6GD">
                    <li class="astro-RQQND6GD">
                        <style>astro-island,astro-slot{display:contents}</style><script>(self.Astro=self.Astro||{}).visible=(i,c,n)=>{const r=async()=>{await(await i())()};let s=new IntersectionObserver(e=>{for(const t of e)if(!!t.isIntersecting){s.disconnect(),r();break}});for(let e=0;e<n.children.length;e++){const t=n.children[e];s.observe(t)}};var a;{const l={0:t=>t,1:t=>JSON.parse(t,n),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(JSON.parse(t,n)),5:t=>new Set(JSON.parse(t,n)),6:t=>BigInt(t),7:t=>new URL(t)},n=(t,r)=>{if(t===""||!Array.isArray(r))return r;const[s,i]=r;return s in l?l[s](i):void 0};customElements.get("astro-island")||customElements.define("astro-island",(a=class extends HTMLElement{constructor(){super(...arguments);this.hydrate=()=>{if(!this.hydrator||this.parentElement?.closest("astro-island[ssr]"))return;const r=this.querySelectorAll("astro-slot"),s={},i=this.querySelectorAll("template[data-astro-template]");for(const e of i)!e.closest(this.tagName)?.isSameNode(this)||(s[e.getAttribute("data-astro-template")||"default"]=e.innerHTML,e.remove());for(const e of r)!e.closest(this.tagName)?.isSameNode(this)||(s[e.getAttribute("name")||"default"]=e.innerHTML);const o=this.hasAttribute("props")?JSON.parse(this.getAttribute("props"),n):{};this.hydrator(this)(this.Component,o,s,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),window.removeEventListener("astro:hydrate",this.hydrate),window.dispatchEvent(new CustomEvent("astro:hydrate"))}}connectedCallback(){!this.hasAttribute("await-children")||this.firstChild?this.childrenConnectedCallback():new MutationObserver((r,s)=>{s.disconnect(),this.childrenConnectedCallback()}).observe(this,{childList:!0})}async childrenConnectedCallback(){window.addEventListener("astro:hydrate",this.hydrate),await import(this.getAttribute("before-hydration-url"));const r=JSON.parse(this.getAttribute("opts"));Astro[this.getAttribute("client")](async()=>{const s=this.getAttribute("renderer-url"),[i,{default:o}]=await Promise.all([import(this.getAttribute("component-url")),s?import(s):()=>()=>{}]),e=this.getAttribute("component-export")||"default";if(!e.includes("."))this.Component=i[e];else{this.Component=i;for(const c of e.split("."))this.Component=this.Component[c]}return this.hydrator=o,this.hydrate},r,this)}attributeChangedCallback(){this.hydrator&&this.hydrate()}},a.observedAttributes=["props"],a))}</script><astro-island uid="1OFPj0" component-url="/SearchBtn.1f41f2c6.js" component-export="default" renderer-url="/client.b27523fa.js" props="{&quot;class&quot;:[0,&quot;astro-RQQND6GD&quot;]}" ssr="" client="visible" before-hydration-url="data:text/javascript;charset=utf-8,//[no before-hydration script]" opts="{&quot;name&quot;:&quot;SearchBtn&quot;,&quot;value&quot;:true}" await-children=""><button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M16.2071 4.89344C19.0923 7.77862 19.3131 12.3193 16.8693 15.4578C16.8846 15.4713 16.8996 15.4854 16.9143 15.5L21.1569 19.7427C21.5474 20.1332 21.5474 20.7664 21.1569 21.1569C20.7664 21.5474 20.1332 21.5474 19.7427 21.1569L15.5 16.9143C15.4854 16.8996 15.4713 16.8846 15.4578 16.8693C12.3193 19.3131 7.77862 19.0923 4.89344 16.2071C1.76924 13.083 1.76924 8.01763 4.89344 4.89344C8.01763 1.76924 13.083 1.76924 16.2071 4.89344ZM14.7929 14.7929C17.1361 12.4498 17.1361 8.6508 14.7929 6.30765C12.4498 3.96451 8.6508 3.96451 6.30765 6.30765C3.96451 8.6508 3.96451 12.4498 6.30765 14.7929C8.6508 17.1361 12.4498 17.1361 14.7929 14.7929Z" fill="currentColor"></path></svg></button></astro-island>
                    </li>
                    <li class="astro-RQQND6GD">
                        <a href="https://github.com/highlandcows/website" title="Highland Cows's Github URL'" class="astro-RQQND6GD">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" class="astro-RQQND6GD"></path>
</svg>
                        </a>
                    </li>
                    <li class="astro-RQQND6GD">
                        <a href="/rss.xml" title="RSS" class="astro-RQQND6GD">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9" class="astro-RQQND6GD"></path><path d="M4 4a16 16 0 0 1 16 16" class="astro-RQQND6GD"></path><circle cx="5" cy="19" r="1" class="astro-RQQND6GD"></circle>
</svg>
                        </a>
                    </li>
                    <li class="astro-RQQND6GD">
                        <astro-island uid="Z1H5hcK" component-url="/ModeSwitcherBtn.b4f11dc9.js" component-export="default" renderer-url="/client.b27523fa.js" props="{&quot;class&quot;:[0,&quot;astro-RQQND6GD&quot;]}" ssr="" client="visible" before-hydration-url="data:text/javascript;charset=utf-8,//[no before-hydration script]" opts="{&quot;name&quot;:&quot;ModeSwitcherBtn&quot;,&quot;value&quot;:true}" await-children=""><button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></button></astro-island>
                    </li>
                </ul>
            </nav>
        </div>
    </div>
</header>

<nav class="nav py-3 astro-CDCEOP25">
    <ul class="nav-list dark:text-primarySecondaryDark astro-CDCEOP25">
         <li class="astro-CDCEOP25">
                <a class="hover:underline astro-CDCEOP25" href="/" title="home">Home</a>
            </li><li class="astro-CDCEOP25">
                <a class="hover:underline astro-CDCEOP25" href="/blog" title="blog">Blog</a>
            </li><li class="astro-CDCEOP25">
                <a class="hover:underline astro-CDCEOP25" href="/tags" title="tags">Tags</a>
            </li><li class="astro-CDCEOP25">
                <a class="hover:underline astro-CDCEOP25" href="/about" title="about">About</a>
            </li>
    </ul>
</nav>
<div class="content astro-QG7TIMHI">
        <div class="post__header astro-7DC3FJFN">
            <div class="post__tags astro-7DC3FJFN">
                <a class="post__tag astro-7DC3FJFN" href="/tags/cli" title="cli">cli</a><a class="post__tag astro-7DC3FJFN" href="/tags/unix" title="unix">unix</a><a class="post__tag astro-7DC3FJFN" href="/tags/linux" title="linux">linux</a>
            </div>
            <h1 class="post__title astro-7DC3FJFN">The Unix CLI: You&#39;re Still The One</h1>
            <h5 class="post__desc astro-7DC3FJFN">
                <a class="post__author astro-7DC3FJFN" href="https://twitter.com/njacobs5074" title="Nick Jacobs's twitter" target="_blank" rel="external">Nick Jacobs</a> |
                <span class="post__date astro-7DC3FJFN">Tuesday, May 1, 2018</span>
            </h5>
        </div><article class="prose dark:prose-dark astro-H65O22HM">
    <blockquote>
<p>You’re still the one — who can scratch my itch<br>
Still the one — and I wouldn’t switch<br>
We’re still having fun, and you’re still the one<br></p>
</blockquote>
<p style="text-align: center">"Still The One" by Orleans, 1976</p>
<h1 id="what-is-the-unix-command-line-interface">What Is The Unix Command Line Interface?</h1>
<p>For the uninitiated, the Unix command line (aka the “shell”) interface is a way of running
programs (aka commands) on a computer using only the keyboard.  The command line requires
you to type in the names of programs to run them. Here is a snippet of a command line
interaction:</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">[tic-tac-toe]$ ls</span></span>
<span class="line"><span style="color: #c9d1d9">LICENSE      bower.json       package.json</span></span>
<span class="line"><span style="color: #c9d1d9">README.md    karma.conf.js    test/</span></span>
<span class="line"><span style="color: #c9d1d9">app/         node_modules/    tic-tac-toe.iml</span></span></code></pre>
<p>Let’s understand briefly what we’re looking at here:</p>
<ol>
<li><code>[tic-tac-toe]$</code> — That’s the “prompt”, i.e. the computer’s way of letting you know that it’s ready for you to type a command.  Note that I’ve <em>customized</em> my prompt to include my current directory.</li>
<li><code>ls</code> — That’s the bit that I typed.  <code>ls</code> is the Unix/Linux command to <em>list</em> the contents of a directory.</li>
<li>The rest is the output of the <code>ls</code> command and then computer prints the prompt again to let you know that you can type another command.</li>
</ol>
<p>One could justifiably look at the above and question why go to all of this trouble just to view the contents of a directory (or “folder” as it’s often called).  After all, there are easier ways to do this and they’re just a mouse click or two away.  Despite this, computer users, and especially coders and system/network administrators use the command line, often to almost complete exclusion of modern graphical user interfaces.</p>
<p>Why is this?  As is often the case, a satisfying answer is not as simple as one would expect and is the topic of this essay.</p>
<p><em>NB: I will use the term “Unix” interchangeably with “Linux” for most of this essay.  While purists may bridle at this distinction, with good reason, I hope that this “sloppiness” does not offend too many.</em></p>
<h1 id="a-bit-of-history">A Bit Of History</h1>
<p>Unix™, meaning the proprietary operating system written by AT&#x26;T Bell Laboratories’ researchers, had its roots in the late 1960s when operating systems research was a big topic, both in academia and commercially.  Much of the development was done and completed by the mid 1970s.  User interface technology of that era was much different than now with teletype terminals (old-style green screens with keyboards aka TTYs) and line printers for hard copy.  Networking was a primitive affair afforded by low-speed modems.  I suspect that the widespread use of modems for Unix peripherals was in no small part due to the fact that AT&#x26;T had a monopoly on modems until the early 1970s.</p>
<p>The command line interface was the primary way to interact with the operating system.  Even the original Unix text editor, <code>ed</code>, was a line-oriented program<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>.</p>
<p>However, the authors<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup> of the Unix command line program (aka the “shell” or the “Bourne shell”) were the same people who designed and built the Unix operating system.  Their vision of computing was revolutionary and their design continues to influence how software is written to this day.</p>
<p>In fact, the command line, driven by a low-tech user interface, exposed a wealth of sophistication provided by the operating system in terms of scripting, batch jobs (i.e. programs that can be run on a specific schedule), and extensibility.  If you didn’t like something, you could extend or even replace it.</p>
<p>This philosophy was taken to the next level in 1991 by Linus Torvalds when he released, as open source, the Linux kernel.<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>  He, along with many other technical users of the Unix operating system were frustrated by AT&#x26;T’s unwillingness to release their operating system as open source.  Linus Torvalds went on to succeed where a number of others had failed and as a result software developers and users have benefitted enormously in the subsequent decades.</p>
<p>As an aside, the willingness and availability of AT&#x26;T and the architects to spend time teaching and disseminating their work in academic institutions such as UC Berkeley during the 1970s played a key role in Unix’s subsequent popularity.</p>
<h2 id="my-journey-with-the-unix-command-line">My journey with the Unix Command Line</h2>
<p>My own use of the Unix command line started when a computer science student at NYU in the early 1980s.  A good friend also studying CS, very kindly gave me access to her Unix account which happened to be running the <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD variant</a> of Unix.  She directed me to a program called <a href="https://www.unix.com/man-page/bsd/1/LEARN/">“learn”</a> that provided an interactive means of learning basic Unix commands, how files worked, and even <code>vi</code>, a fullscreen text editor.</p>
<p>Although the <code>learn</code> command helped me to understand the basic commands in just a few short sessions, more complete mastery of the shell occurred when I got a summer job at a small, local software company.  The founder of the company taught Unix and C programming to local corporates and during the course of that summer, he taught me not only the mechanics of programming on Unix but the philosophy that I have alluded to in the previous paragraphs.</p>
<p>His teachings were very straightforward and built on the core philosophy of write tools that cooperate and extend.  It is this philosophy that I will illustrate and encourage in the next few paragraphs.</p>
<h2 id="starting-with-the-shell">Starting With The Shell</h2>
<p>If you own an Apple computer or have already installed Linux on a computer, you probably know that there is a command line interface available.  There is also a command line interface on Microsoft-based operating systems, but it differs considerably from the Unix-derived ones and I will not go into detail discussing it here.<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup></p>
<p>At its most basic, the shell is simply a way of typing a command and getting a result.  The example at the beginning of this essay showed a directory listing.  However, I’m not going to dive into a tutorial on how to use the shell.  There are many such resources on the net and I doubt that I can do better.</p>
<p>Instead, what I want to direct your attention to is the typical facilities that modern shell programs provide.  For example, most shell programs, e.g. <code>bash</code>, <code>zsh</code>, <code>tcsh</code>, etc all provide high level facilities for:</p>
<ul>
<li>File I/O</li>
<li>Text/data manipulation</li>
<li>Parallel processing</li>
<li>Remote program execution</li>
<li>Job control</li>
</ul>
<p>These facilities are then provided in what is commonly referred to as a REPL (Read-Evaluate-Print-Loop).  This is a precise definition of a user interface in which you provide a command to the program, the shell in this case, it interprets or evaluates that command, prints out the results and then waits for you to type a new command.</p>
<p>By the way, one can also extend this facility by saving useful series of commands into a file often called a script.  The script can then be executed as any other command that was previously installed on the computer.</p>
<h3 id="file-io-and-textdata-manipulation">File I/O and Text/Data Manipulation</h3>
<p>What makes this facility even more powerful is that the commands that you type and thus are executed by the shell on your behalf are for the most part not aware that their output is going to your screen.  Instead they simply write their output to a standard system destination called STDOUT (pronounced “standard out”).  The shell arranges for the command’s STDOUT to be connected to the terminal.  But it also makes it very easy to redirect that output to a file when the user specifies <code>> some-file</code>.  The <code>></code> character signifies output redirection.  Similarly, you can tell the shell that you’d like the command to read its input from a file (as opposed to the keyboard) by simply specifying <code>&#x3C; some-other-file</code> on the command line.  That program has no idea whether its input is from a file or the keyboard.</p>
<p>Thus, the shell provides a simple but powerful way to manage files and their content.</p>
<h3 id="parallel-processing">Parallel Processing</h3>
<p>Perhaps somewhat amazingly, the Unix shell has supported parallel processing since its earliest days.  The Unix kernel provides a facility called ‘pipes’ that allow a series of programs to be connected together such that each command in the pipeline’s output is connected to the succeeding command’s input.  These programs can then run in parallel and the pipeline completes when all of the output from the first command has been processed by the subsequent commands.  The shell exposes this facility using the ’|’ character, often referred to as the “pipe character” for pretty obvious reasons.</p>
<p>Note that the degree of parallelism exposed here is called “coarse-grained” parallelism.  The reason for this is that the smallest computational unit available to the shell is an entire command.  This is contrast to fine-grained parallelism where the computational unit could be a very lightweight component such as thread responsible for simply multiplying 2 numbers together.  Thus the parallelism that the shell exposes is appropriate for tasks such as transforming a text file or searching a log file for errors but would be inefficient for matrix multiplications.</p>
<p>Still this parallelism has been used in some places quite successfully, for example, compilers for the C programming language have been written to use pipes instead of temporary files to improve performance (keep in mind that at the time, hard drives were considerably slower than they are today).  I’ve written simple log monitoring tools that relied upon the ability to continuously scan system logs for specific entries such as errors and then hand off those entries to yet another program for further classification.</p>
<p>Again, the point of all of this is that underlying design of Unix and then the shell’s leveraging of those capabilities has allowed successive generations of software developers to extend the platform in novel ways.</p>
<p>However, the above capabilities (I/O, data manipulation, and so on) are facilities that are provided by most programming languages and their attendant run-time environments.  What makes the shell so different? I think its power (and success) can be attributed to the following:</p>
<ul>
<li>Ubiquity — The command line interface is available on all Unix/Linux computers.</li>
<li>Immediacy — There’s a tight feedback loop when you use it.  If you mistype a command, you’re told immediately of the error.  Modern shells have extensive in-place editing capabilities that make it easy to fix these errors.</li>
<li>Power — While the shell presents a high-level interface, it is a programming language with loop constructs, variables, functions, and so forth, it also allows you to directly manipulate the computer you’re using at very low levels.</li>
<li>Immersiveness — The shell provides little in the way of distraction and I believe that given the deep level of concentration that is required for coding, this makes it a very productive way to interact with a computer.  There are no attempts by unrelated programs to “engage” you in other activities. :)</li>
</ul>
<p>The shell is, by and large, a tool written by and designed for use by a highly technical audience, even within the tech community itself.  While at some point in Unix’s history, there may have been a more general audience of moderately technical users, the advent of GUI applications has made other user interfaces more accessible and thus the command line has become largely the province of coders.</p>
<h3 id="file-io-and-text-manipulation">File I/O and Text Manipulation</h3>
<p>One of the main abstractions that operating systems provide is for reading and writing data.  By providing standard, albeit low-level interfaces to peripherals such as disk drives, they make it possible for programmers to largely ignore the differences between different manufacturers’ products.</p>
<p>File I/O is a core operating system function and is the native persistence mechanism provided to applications.  However, in Unix a standard way of reading and writing file content<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup> is provided via 2 abstractions:</p>
<ul>
<li>Standard In - Often written as STDIN, this is a special file that a program can use for input of any kind.</li>
<li>Standard Out - Often written as STDOUT, this is a special file that, you guessed it, a program can use for output, again of whatever it wants.</li>
</ul>
<p>The Unix shell took this underlying abstraction and provided a very elegant and powerful syntax for using it. For example, simply using the ’>’ character after a command, one can <em>redirect</em> the output of that command to a file.  Similarly, the input of a program can set by using the ’&#x3C;’ character.  The program has no idea that this is being done, by the way, as reading and writing the keyboard or screen looks just like a file as well.</p>
<p>However where the real power comes in is that you can connect one program’s output to another program’s input using a Unix construct called a “pipe”.  Pipes are a facility provided by the operating system but are exposed at the command line using the ’|’ character.</p>
<p>The ease with which this facility can be used can be demonstrated here.</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ tail -f /var/log/system.log | grep -i error</span></span></code></pre>
<p>Without going into the details, the file <code>system.log</code> is has all kinds of useful messages written to it by various components in macOS.  But suppose that I just want to keep track of the errors?  And suppose I want to list those as they happen?</p>
<p>The above command does that and here is how it works.</p>
<ol>
<li><code>tail -f /var/log/system.log</code> — Display the output of the system log “forever”, thus the <code>-f</code> option to the command</li>
<li><code>|</code> — Pipe the output of <code>tail</code> command to another program…</li>
<li><code>grep -i error</code> — Search for all the instances of the word ‘error’ (irrespective of case, thus the <code>-i</code>) and display them on <code>grep</code>’s standard output, which in this case is the terminal where I typed all of the above.</li>
</ol>
<p>Here is some sample output:</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">Mar 10 16:26:21 Nick-iMac secd[457]:  securityd_xpc_dictionary_handler cloudd[468] copy_matching Error Domain=NSOSStatusErrorDomain Code=-50 "query missing class name" (paramErr: error in user parameter list) UserInfo={NSDescription=query missing class name}</span></span>
<span class="line"><span style="color: #c9d1d9">Mar 10 16:26:21 Nick-iMac cloudd[468]:  SecOSStatusWith error:[-50] Error Domain=NSOSStatusErrorDomain Code=-50 "query missing class name" (paramErr: error in user parameter list) UserInfo={NSDescription=query missing class name}</span></span>
<span class="line"><span style="color: #c9d1d9">...</span></span></code></pre>
<p>Ignoring for a moment the details of the about output, let us marvel at how powerful this is.  Having typed less than 100 characters, I can easily find out system errors almost instantly and this is just the beginning.  By using nothing more than the keyboard, there are 1000s of commands available whose outputs and inputs can be filtered and manipulated either on the fly or by saving them into text files that I can run in the same way I run any other program on the system.</p>
<p>In other words, my reward for investing the time to learn an arguably terse and cryptic interface is a fantastic return in productivity.</p>
<p>But when you consider what a coder does all day long, typing terse and cryptic text, this is a difference in kind not quality.</p>
<section data-footnotes="" class="footnotes"><h2 id="footnote-label" class="sr-only">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p>This was not to change until Bill Joy, while a student at University California Berkeley, in 1977 wrote one of the first programs for Unix that ran in full-screen mode, a text editor called <code>vi</code> (for “visual”). <a href="https://en.wikipedia.org/wiki/Vi">https://en.wikipedia.org/wiki/Vi</a> <a href="#user-content-fnref-1" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-2">
<p><a href="https://en.wikipedia.org/wiki/Unix">https://en.wikipedia.org/wiki/Unix</a> <a href="#user-content-fnref-2" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-3">
<p><a href="https://en.wikipedia.org/wiki/Linux">https://en.wikipedia.org/wiki/Linux</a> - You may have noticed that Unix is, in fact, a trademark.  Linus Torvalds, like many developers, was frustrated by the proprietary and closed nature of the Unix operating system, particularly the kernel.  Unlike many others, he wrote his own. :) <a href="#user-content-fnref-3" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-4">
<p>If you want a reasonable facsimile of the Unix command line on Windows, I strongly recommend that you install <a href="https://www.cygwin.com">Cygwin</a>, an open source and very complete port of the Unix command line to Windows. <a href="#user-content-fnref-4" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-6">
<p>Historically, there has been a very text-centric aspect to application data on Unix, but there are examples where this approach has been used even for binary data. TODO: Find a pointer to the Unix C compiler’s pipes architecture for its different stages. <a href="#user-content-fnref-6" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section>
</article>


    </div><br class="my-4 astro-QG7TIMHI"><footer class="footer astro-JPYZMR4T">
    <nav class="nav astro-JPYZMR4T">
        <div class="astro-JPYZMR4T">2022  &copy; Copyright notice |  <a href="https://github.com/highlandcows/website" title="Highland Cows's Github URL'" class="astro-JPYZMR4T">Highland Cows</a>
        <script>(self.Astro=self.Astro||{}).load=a=>{(async()=>await(await a())())()};</script><astro-island uid="1hRzmE" component-url="/ModeLabel.76ecfc10.js" component-export="default" renderer-url="/client.b27523fa.js" props="{&quot;class&quot;:[0,&quot;astro-JPYZMR4T&quot;]}" ssr="" client="load" before-hydration-url="data:text/javascript;charset=utf-8,//[no before-hydration script]" opts="{&quot;name&quot;:&quot;ModeLabel&quot;,&quot;value&quot;:true}" await-children=""><span slot="dark">(dark)</span></astro-island> theme on <a href="https://astro.build/" class="astro-JPYZMR4T">Astro</a></div>
    </nav>
</footer>
<div class="portal-root">
    <astro-island uid="27vCTE" component-url="/SearchModal.9e018223.js" component-export="default" renderer-url="/client.b27523fa.js" props="{&quot;class&quot;:[0,&quot;astro-QG7TIMHI&quot;]}" ssr="" client="load" before-hydration-url="data:text/javascript;charset=utf-8,//[no before-hydration script]" opts="{&quot;name&quot;:&quot;SearchModal&quot;,&quot;value&quot;:true}"></astro-island>
</div>
        </main>
    </div>
</body>



</html>